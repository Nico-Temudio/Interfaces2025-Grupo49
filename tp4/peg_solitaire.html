<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Peg Solitaire - Entrega</title>
  <style>
    /* Página y layout */
    html,body{height:100%;margin:0;background:#0b1220;color:#fff;font-family:Inter, system-ui, sans-serif}
    .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px;box-sizing:border-box}
    .card{width:1600px;max-width:calc(100vw - 48px);background:linear-gradient(180deg,#0f1724 0%, #07101a 100%);border-radius:14px;padding:18px;box-shadow:0 12px 40px rgba(0,0,0,.6)}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
    h1{font-size:20px;margin:0}
    .controls{display:flex;gap:12px;align-items:center}
    button{background:#13202b;border:1px solid rgba(255,255,255,.06);color:#dff3ff;padding:8px 12px;border-radius:8px;cursor:pointer}
    .muted{opacity:.8;font-size:13px}
    #canvasContainer{display:flex;justify-content:center}
    /* canvas is sized to fit inside FullHD (1920x1080) without scrolling */
    canvas{display:block;border-radius:8px;background:#e8edea;box-shadow:0 8px 30px rgba(0,0,0,.5)}
    .footer{margin-top:10px;display:flex;justify-content:space-between;align-items:center}
    .theme-select{display:flex;gap:8px;align-items:center}
    .timer{font-weight:700}
    /* small responsive tweak */
    @media (max-width:900px){.card{padding:8px}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1>Peg Solitaire — Entrega</h1>
        <div class="controls">
          <div class="muted">Tiempo límite:</div>
          <select id="timeLimit">
            <option value="180">3 minutos</option>
            <option value="300" selected>5 minutos</option>
            <option value="600">10 minutos</option>
          </select>
          <div class="muted">Tema:</div>
          <select id="themeSelect" class="theme-select">
            <option value="classic">Madera (Classic)</option>
            <option value="gems">Gemas</option>
            <option value="stars">Estrellas</option>
          </select>
          <button id="restartBtn">Reiniciar</button>
          <button id="resetBoardBtn">Tablero Vacío</button>
        </div>
      </header>

      <div id="canvasContainer">
        <canvas id="gameCanvas" width="1600" height="900"></canvas>
      </div>

      <div class="footer">
        <div class="muted">Movimientos: <span id="movesCount">0</span></div>
        <div class="muted timer">Tiempo restante: <span id="timerDisplay">--:--</span></div>
      </div>
    </div>
  </div>

<script>
/*
  Peg Solitaire - implementación orientada a objetos.
  - Canvas con fondo temático.
  - Piezas dibujadas mediante imágenes (SVG data URLs incluidos) — cumple con "no color sólido".
  - Drag & drop con selección por click y arrastre.
  - Hints animados (flechas pulsantes) mostrados sobre casillas destino válidas mientras arrastras.
  - Lógica del juego (movimientos en cruz: saltar ficha vecina, eliminarla).
  - Detección de fin de juego (sin movimientos posibles) después de cada jugada.
  - Reinicio, timer con límite, múltiples temas.

  Comentarios en TODOS los métodos explicando su propósito.
*/

// -------------------- Recursos (imágenes SVG embebidas como data URLs) --------------------
const IMAGES = {
  boardBg: `data:image/svg+xml;utf8,${encodeURIComponent(`
    <svg xmlns='http://www.w3.org/2000/svg' width='1600' height='900'>
      <defs>
        <pattern id='p' width='40' height='40' patternUnits='userSpaceOnUse'>
          <rect width='40' height='40' fill='%23101410' />
          <path d='M0 0 L40 0 L40 40' fill='none' stroke='%231b2b25' stroke-width='1' />
        </pattern>
      </defs>
      <rect width='100%' height='100%' fill='%230b1220' />
      <g opacity='0.08'>
        <rect x='60' y='60' width='1480' height='780' rx='10' fill='url(%23p)' />
      </g>
    </svg>
  `)}`,
  // Fichas: tres estilos (madera, gema, estrella) — cada uno es un SVG embebido
  wood: `data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'>
    <defs>
      <linearGradient id='g' x1='0' x2='1'>
        <stop offset='0' stop-color='%23c28b4a'/>
        <stop offset='1' stop-color='%2375442b'/>
      </linearGradient>
    </defs>
    <rect rx='50' width='100%' height='100%' fill='url(%23g)' />
    <circle cx='100' cy='100' r='44' fill='rgba(255,255,255,0.06)' />
    <text x='50%' y='54%' dominant-baseline='middle' text-anchor='middle' font-size='64' fill='%23ffffff' opacity='0.85'>♟</text>
  </svg>`)}`,

  gems: `data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'>
    <polygon points='100,16 140,80 100,120 60,80' fill='%23e11' stroke='%23fee' stroke-width='3' />
    <text x='50%' y='78%' dominant-baseline='middle' text-anchor='middle' font-size='44' fill='rgba(255,255,255,0.95)'>♦</text>
  </svg>`)}`,

  stars: `data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'>
    <rect width='100%' height='100%' rx='30' fill='%23235' />
    <text x='50%' y='54%' dominant-baseline='middle' text-anchor='middle' font-size='72' fill='%23ffd700'>★</text>
  </svg>`)}`
};

// -------------------- Constantes del tablero --------------------
const ROWS = 7; // tablero tipo "English" 7x7 con esquinas inválidas
const COLS = 7;
const CELL_GAP = 6; // espacio entre casillas

// Posiciones inválidas en esquinas (true = es casilla no utilizable)
const INVALID = [
  [1,1,0,0,0,1,1],
  [1,1,0,0,0,1,1],
  [0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0],
  [1,1,0,0,0,1,1],
  [1,1,0,0,0,1,1]
];

// -------------------- Clases --------------------

/** Clase que representa una celda del tablero. */
class Cell {
  /**
   * @param {number} r - fila
   * @param {number} c - columna
   * @param {number} x - coordenada x en canvas (centro)
   * @param {number} y - coordenada y en canvas (centro)
   * @param {number} size - tamaño de la celda
   * @param {boolean} valid - si la celda es utilizable en el juego
   */
  constructor(r,c,x,y,size,valid){
    this.r = r; this.c = c; this.x = x; this.y = y; this.size = size; this.valid = valid;
    this.piece = null; // referencia a Piece si existe
  }

  /** Dibuja el contorno y la base de la celda. */
  draw(ctx){
    ctx.save();
    // base
    ctx.beginPath();
    roundRect(ctx, this.x - this.size/2, this.y - this.size/2, this.size, this.size, 8);
    ctx.fillStyle = this.valid ? 'rgba(255,255,255)' : 'rgba(0,0,0,0.0)';
    ctx.fill();
    // borde sutil
    ctx.beginPath();
    const cx = this.x  // centro X del casillero
    const cy = this.y  // centro Y del casillero
    const radius = this.size / 2.5;     // tamaño del círculo
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.fillStyle = this.valid ? '#b0b0b0' : '#0000';              // color de relleno gris
    ctx.fill();

    ctx.lineWidth = 5;
    ctx.strokeStyle = this.valid ? 'rgba(255,150,150)' : 'rgba(0,0,0,0)';
    ctx.stroke();
    ctx.restore();
  }
}

/** Clase que representa una ficha (Piece). */
class Piece {
  /**
   * @param {Cell} cell - celda donde comienza la pieza
   * @param {Image} img - imagen a dibujar para la ficha
   * @param {string} id - identificador único
   */
  constructor(cell, img, id){
    this.cell = cell; // referencia a la cell
    this.img = img;   // Image object
    this.id = id;
    this.size = cell.size * 0.86; // tamaño visual
    this.offsetX = 0; this.offsetY = 0; // offset durante el drag
    this.isDragging = false;
  }

  /** Dibuja la pieza en su posición actual (considerando offset si arrastrando). */
  draw(ctx){
    const drawX = (this.cell.x + this.offsetX) - this.size/2;
    const drawY = (this.cell.y + this.offsetY) - this.size/2;
    ctx.save();
    roundRect(ctx, drawX, drawY, this.size, this.size, this.size*0.18);
    ctx.clip();
    // dibuja la imagen
    try{
      ctx.drawImage(this.img, drawX, drawY, this.size, this.size);
    }catch(e){
      // en caso de error, dibujar fallback
      ctx.fillStyle = '#444';
      ctx.fillRect(drawX, drawY, this.size, this.size);
    }
    ctx.restore();

    // si arrastrando, dibujar sombra simple
    if(this.isDragging){
      ctx.save();
      ctx.globalAlpha = 0.12;
      roundRect(ctx, drawX+6, drawY+8, this.size, this.size, this.size*0.18);
      ctx.fill();
      ctx.restore();
    }
  }

  /** Obtiene el centro actual en canvas (considerando offset). */
  getCenter(){
    return {x: this.cell.x + this.offsetX, y: this.cell.y + this.offsetY};
  }
}

/** Clase principal del tablero que contiene celdas y piezas y maneja la lógica. */
class Board {
  /**
   * @param {CanvasRenderingContext2D} ctx - contexto 2D del canvas
   * @param {number} width - ancho del canvas
   * @param {number} height - alto del canvas
   */
  constructor(ctx,width,height){
    this.ctx = ctx; this.width = width; this.height = height;
    this.cells = []; // matriz de Cell
    this.pieces = []; // lista de Piece
    this.cellSize = 0; // se calculará
    this.theme = 'classic';
    this.images = {}; // imagenes cargadas por tema
    this.moves = 0;

    // preparar imagenes Image() desde dataURLs
    this.preloadImages();

    // construir geometría del tablero y celdas
    this._buildGrid();
  }

  /** Carga las imágenes (data URLs) en objetos Image. */
  preloadImages(){
    this.images.wood = new Image(); this.images.wood.src = IMAGES.wood;
    this.images.gems = new Image(); this.images.gems.src = IMAGES.gems;
    this.images.stars = new Image(); this.images.stars.src = IMAGES.stars;
    this.images.bg = new Image(); this.images.bg.src = IMAGES.boardBg;
  }

  /** Construye la disposición de celdas en el canvas y calcula tamaños. */
  _buildGrid(){
    // reservar 80% del ancho del área central para tablero
    const padX = 120; const padY = 60;
    const availableW = this.width - padX*2;
    const availableH = this.height - padY*2;
    const size = Math.min((availableW - (COLS-1)*CELL_GAP)/COLS, (availableH - (ROWS-1)*CELL_GAP)/ROWS);
    this.cellSize = Math.floor(size);
    const boardW = COLS*this.cellSize + (COLS-1)*CELL_GAP;
    const boardH = ROWS*this.cellSize + (ROWS-1)*CELL_GAP;
    const startX = (this.width - boardW)/2 + this.cellSize/2;
    const startY = (this.height - boardH)/2 + this.cellSize/2;

    this.cells = [];
    for(let r=0;r<ROWS;r++){
      const row = [];
      for(let c=0;c<COLS;c++){
        const x = startX + c*(this.cellSize + CELL_GAP);
        const y = startY + r*(this.cellSize + CELL_GAP);
        const valid = INVALID[r][c] === 0;
        row.push(new Cell(r,c,x,y,this.cellSize,valid));
      }
      this.cells.push(row);
    }
  }

  /** Inicializa las piezas en el tablero (posición inicial clásica: centro vacío). */
  initPieces(emptyCenter=true){
    this.pieces = [];
    this.moves = 0;
    let idCounter = 0;
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = this.cells[r][c];
        if(!cell.valid) continue;
        // por defecto llenar todas menos el centro (3,3)
        if(emptyCenter && r===3 && c===3) { cell.piece=null; continue; }
        const img = this._getThemeImage();
        const piece = new Piece(cell,img,'p'+(idCounter++));
        cell.piece = piece;
        this.pieces.push(piece);
      }
    }
  }

  /** Devuelve la Image correspondiente al tema actual. */
  _getThemeImage(){
    if(this.theme==='classic') return this.images.wood;
    if(this.theme==='gems') return this.images.gems;
    if(this.theme==='stars') return this.images.stars;
    return this.images.wood;
  }

  /** Dibuja el tablero completo: fondo, celdas y piezas. */
  draw(){
    // fondo temático
    this.ctx.save();
    // dibujar background image (pattern)
    if(this.images.bg.complete) this.ctx.drawImage(this.images.bg,0,0,this.width,this.height);
    this.ctx.restore();

    // dibujar celdas
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        this.cells[r][c].draw(this.ctx);
      }
    }

    // dibujar piezas no arrastrando primero
    for(const p of this.pieces){ if(!p.isDragging) p.draw(this.ctx); }
    // luego las que están arrastrando dibujamos arriba
    for(const p of this.pieces){ if(p.isDragging) p.draw(this.ctx); }
  }

  /** Encuentra la celda bajo una coordenada x,y (devuelve null si ninguna válida). */
  cellAt(x,y){
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = this.cells[r][c];
        if(!cell.valid) continue;
        const half = cell.size/2;
        if(x >= cell.x - half && x <= cell.x + half && y >= cell.y - half && y <= cell.y + half) return cell;
      }
    }
    return null;
  }

  /** Comprueba si un movimiento de 'fromCell' a 'toCell' es válido según reglas (saltar pieza adyacente). */
  isValidMove(fromCell,toCell){
    if(!fromCell || !toCell) return false;
    if(!fromCell.piece) return false;
    if(toCell.piece) return false; // destino debe estar vacío
    // movimiento estrictamente horizontal o vertical de 2 celdas
    const dr = toCell.r - fromCell.r;
    const dc = toCell.c - fromCell.c;
    if(Math.abs(dr)===2 && dc===0){
      // hay que haber una pieza entre medias
      const mid = this.cells[fromCell.r + dr/2][fromCell.c];
      return mid && mid.piece;
    }
    if(Math.abs(dc)===2 && dr===0){
      const mid = this.cells[fromCell.r][fromCell.c + dc/2];
      return mid && mid.piece;
    }
    return false;
  }

  /** Realiza el movimiento si es válido: mueve la pieza, elimina la saltada y actualiza contadores. */
  performMove(fromCell,toCell){
    if(!this.isValidMove(fromCell,toCell)) return false;
    const dr = toCell.r - fromCell.r;
    const dc = toCell.c - fromCell.c;
    const midR = fromCell.r + (dr? dr/2 : 0);
    const midC = fromCell.c + (dc? dc/2 : 0);
    const midCell = this.cells[midR][midC];

    // eliminar pieza del medio
    const removed = midCell.piece;
    if(removed){
      // remover de lista
      this.pieces = this.pieces.filter(p => p !== removed);
      midCell.piece = null;
    }

    // mover pieza
    const piece = fromCell.piece;
    fromCell.piece = null;
    toCell.piece = piece;
    piece.cell = toCell;
    piece.offsetX = 0; piece.offsetY = 0; piece.isDragging = false;

    this.moves++;
    return true;
  }

  /** Verifica si existe al menos un movimiento posible en todo el tablero. */
  hasAnyMoves(){
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = this.cells[r][c];
        if(!cell.valid || !cell.piece) continue;
        const deltas = [[2,0],[-2,0],[0,2],[0,-2]];
        for(const d of deltas){
          const nr = r + d[0]; const nc = c + d[1];
          if(nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
          const target = this.cells[nr][nc];
          if(this.isValidMove(cell,target)) return true;
        }
      }
    }
    return false;
  }

  /** Cambia el tema de imágenes y actualiza todas las fichas. */
  setTheme(name){
    this.theme = name;
    const img = this._getThemeImage();
    for(const p of this.pieces) p.img = img;
  }

  /** Obtiene ficha en coordenadas (x,y) - devuelve Piece o null. */
  pieceAt(x,y){
    for(const p of this.pieces){
      const center = p.getCenter();
      const half = p.size/2;
      if(x>=center.x-half && x<=center.x+half && y>=center.y-half && y<=center.y+half) return p;
    }
    return null;
  }
}

// -------------------- Utilidades --------------------

/** Dibuja un rectángulo redondeado en el contexto. */
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/** Formatea segundos a MM:SS */
function formatTime(sec){
  const s = Math.max(0,Math.floor(sec));
  const mm = Math.floor(s/60).toString().padStart(2,'0');
  const ss = (s%60).toString().padStart(2,'0');
  return mm+':'+ss;
}

// -------------------- UI + Input + Loop --------------------

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const board = new Board(ctx, canvas.width, canvas.height);
let draggingPiece = null; // referencia a Piece
let dragStartCell = null; // celda origen
let validTargetsDuringDrag = []; // lista de cells donde se puede soltar
let lastTick = 0;

// Timer
let timeLimit = parseInt(document.getElementById('timeLimit').value,10);
let timeRemaining = timeLimit;
let timerInterval = null;

// DOM elements
const movesCountEl = document.getElementById('movesCount');
const timerDisplayEl = document.getElementById('timerDisplay');
const themeSelect = document.getElementById('themeSelect');

// Inicializar
board.initPieces(true);
board.setTheme(themeSelect.value);
movesCountEl.textContent = board.moves;
updateTimerDisplay();
startTimer();

// -------------------- Eventos del mouse (click + drag) --------------------

canvas.addEventListener('mousedown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width/rect.width);
  const y = (e.clientY - rect.top) * (canvas.height/rect.height);
  const p = board.pieceAt(x,y);
  if(p){
    // seleccionar ficha
    draggingPiece = p;
    dragStartCell = p.cell;
    p.isDragging = true;
    p.offsetX = 0; p.offsetY = 0;
    // calcular targets válidos para esta ficha
    validTargetsDuringDrag = [];
    const deltas = [[2,0],[-2,0],[0,2],[0,-2]];
    for(const d of deltas){
      const nr = p.cell.r + d[0]; const nc = p.cell.c + d[1];
      if(nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
      const target = board.cells[nr][nc];
      if(board.isValidMove(p.cell,target)) validTargetsDuringDrag.push(target);
    }
  }
});

canvas.addEventListener('mousemove', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width/rect.width);
  const y = (e.clientY - rect.top) * (canvas.height/rect.height);
  if(draggingPiece){
    // actualizar offset relativo al centro de la celda
    draggingPiece.offsetX = x - draggingPiece.cell.x;
    draggingPiece.offsetY = y - draggingPiece.cell.y;
  }
});

canvas.addEventListener('mouseup', (e)=>{
  if(!draggingPiece) return;
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width/rect.width);
  const y = (e.clientY - rect.top) * (canvas.height/rect.height);
  const dropCell = board.cellAt(x,y);
  let moved = false;
  if(dropCell && board.isValidMove(dragStartCell, dropCell)){
    // realizar movimiento
    moved = board.performMove(dragStartCell, dropCell);
  }
  // si no moved, regresar pieza a su origen
  if(!moved){
    draggingPiece.offsetX = 0; draggingPiece.offsetY = 0; draggingPiece.isDragging = false;
  }
  draggingPiece = null;
  dragStartCell = null;
  validTargetsDuringDrag = [];

  // actualizar estado
  movesCountEl.textContent = board.moves;
  // después de mover, verificar si hay movimientos posibles
  if(!board.hasAnyMoves()){
    // fin de juego
    stopTimer();
    setTimeout(()=>{
      alert('Juego terminado — no hay más movimientos. Movimientos: '+board.moves);
    },80);
  }
});

// Permitir selección por click (sin arrastre). Si hacen click en celda vacía u otra ficha, no pasa nada.
canvas.addEventListener('click', (e)=>{
  // si se hizo click sobre una pieza ya la manejamos en mousedown
});

// Evitar que arrastrar fuera del canvas cause selection de texto
canvas.addEventListener('dragstart', (e)=> e.preventDefault());

// -------------------- Loop de renderizado con hints animados --------------------

let animStart = performance.now();
function loop(ts){
  const elapsed = ts - animStart;
  // limpiar
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // dibujar tablero
  board.draw();

  // Si estamos arrastrando, dibujar hints animados sobre validTargetsDuringDrag
  if(validTargetsDuringDrag.length>0){
    drawHints(ctx, validTargetsDuringDrag, (elapsed/1000));
  }

  lastTick = ts;
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/** Dibuja flechas / hints animados sobre una lista de celdas. */
function drawHints(ctx, cells, t){
  for(const cell of cells){
    if(cell.valid){
      const cx = cell.x; const cy = cell.y - cell.size*0.42; // arriba de la casilla
      ctx.save();
      // pulso para opacidad y desplazamiento
      const pulse = Math.sin(t*6 + (cell.r+cell.c)) * 6;
      ctx.globalAlpha = 0.9 - (Math.abs(Math.sin(t*3))/2);
      ctx.beginPath();
      // flecha simple triangular
      ctx.moveTo(cx, cy - 18 + pulse);
      ctx.lineTo(cx-14, cy + 6 + pulse);
      ctx.lineTo(cx+14, cy + 6 + pulse);
      ctx.closePath();
      // estilo según tema
      const theme = board.theme;
      if(theme==='classic') ctx.fillStyle = 'rgba(255,230,180)';
      else if(theme==='gems') ctx.fillStyle = 'rgba(0,0,200)';
      else ctx.fillStyle = 'rgba(255,240,120)';
      ctx.fill();

      // anillo pulsante
      ctx.beginPath();
      ctx.arc(cx, cy + 28 + pulse, 12 + Math.abs(Math.sin(t*4))*6, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.restore();
    }
  }
}

// -------------------- Timer y controles --------------------

function updateTimerDisplay(){
  timerDisplayEl.textContent = formatTime(timeRemaining);
}

function startTimer(){
  stopTimer();
  timeLimit = parseInt(document.getElementById('timeLimit').value,10);
  timeRemaining = timeLimit;
  updateTimerDisplay();
  timerInterval = setInterval(()=>{
    timeRemaining--;
    updateTimerDisplay();
    if(timeRemaining<=0){
      stopTimer();
      alert('Se acabó el tiempo. Juego terminado. Movimientos: '+board.moves);
    }
  },1000);
}

function stopTimer(){ if(timerInterval) { clearInterval(timerInterval); timerInterval=null; } }

// eventos DOM
document.getElementById('restartBtn').addEventListener('click', ()=>{
  board.initPieces(true);
  board.setTheme(themeSelect.value);
  movesCountEl.textContent = board.moves;
  startTimer();
});

document.getElementById('resetBoardBtn').addEventListener('click', ()=>{
  // deja el tablero vacío (sin piezas) para testing
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) board.cells[r][c].piece = null;
  board.pieces = [];
  movesCountEl.textContent = board.moves;
});

themeSelect.addEventListener('change', ()=>{
  board.setTheme(themeSelect.value);
});

document.getElementById('timeLimit').addEventListener('change', ()=>{
  startTimer();
});

// -------------------- Final notes: cargar imágenes para asegurar que estén listas --------------------

// Forzar redraw cuando imágenes cargan
for(const k of Object.keys(board.images)){
  board.images[k].onload = ()=>{};
}

</script>
</body>
</html>
